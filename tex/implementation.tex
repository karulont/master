\section{Implementation}
For implementing the model, there were at least two major decisions to be made.
\begin{itemize}
    \item Which optimization software to use?
    \item What programming language to use for generating the model?
\end{itemize}
The author was familiar with a commercial grade optimization solver called
Gurobi~\cite{gurobi}. It is advertised as a state-of-the-art mathematical
programming solver and it has a free, full-featured academic license.
Therefore, other integer programming model solvers were not even considered.
\TODO{Maybe should write a bit more about why Gurobi is the best choice?}

Gurobi has bindings for several languages. The ones considered were C++ and
Python. It is well known that Python as a interpreted language has a constant
runtime overhead. However, C++ has lots of unwanted complexity. The author
chose to use Python, because generating the integer programming model would
only take a fraction of the time to actually solve it. And the model solving
is not hindered by the runtime system of Python. Because there exist lots of
code that still uses version 2.X of Python, it should be explicitly
mentioned that Python 3.X was used in thesis. To be precise, the exact version
was Python 3.5.1.
\subsection{Panda}
Programmers are used to thinking in terms of if clauses. However, in an integer
programming model there are no ifs. At first it was hard to come up with
constraints. You knew which variables are involved and what values are legal,
but writing them as a constraint was still unintuitive. Finding the right
constraint when there were five or more variables proved hard to do by
hand. Fortunately there is a tool called Panda~\cite{panda} to help with
finding constraints.
Panda takes an input file, which list the variables and legal values of the
variables. Then it processes this list of legal values and outputs equalities and inequalities
that hold between the variables.
\TODO{example input and output}
Writing input files for Panda is a little boring, because you have to list all
the legal assignments of values to variables. We wrote little programs with
regular if clauses to generate input files for Panda. Panda outputs lots of
inequalities, but some of them are trivial and already covered by other
constraints in the model. Therefore, human judgement was still needed to see
which inequalities and equalities added something to the integer programming
model.
\subsection{Graphical visualization}
For testing the model and seeing the solutions found, we needed some kind of
feedback. At first we had a textual output of the node status and decision
variables for each timestep.
\TODO{add textual output}
However, when the time came to find out, if edge occupied variables had
reasonable values in the solution, the textual output was not good enough to
display the directed edges well. Instead of improving the textual output, we
chose to implement the visualization of solutions graphically.

Because the visualization was used mostly for debugging purposes, there was not
a lot of effort and time put into writing it. To minimize the effort we wrote
the graphical visualization using the de-facto standard Python graphical user
interface package TkInter~\cite{tkinter}. The graphical visualization shows the
underlying graph of the problem one timestep at a time. There are keybindings
to increase and decrease the visible timestep. For a given timestep, the
occupied edges are highlighted. At each vertex, the node status is displayed
and if one of the decision variables was set to 1, the decision is also displayed
inside the vertex.
\TODO{add example screenshots}
\subsection{Irreducible inconsistent subsystem}
In the development phase errors were made. Sometimes a feasible movement were
not feasible in the integer programming model. This would mean that all the
constraints would need to be carefully verified again. Luckily, Gurobi can
calculate the irreducible inconsistent subsystem of an infeasible model.
Inconsistent subsystem of a integer program is a subset of constraints, that
are inconsistent. Irreducible inconsistent subsystem is the minimal
inconsistent subsystem. Basically we can ask Gurobi to find out which set of
constraints make the model infeasible. After we get such a set, we only have
recheck the constraints that are in the irreducible inconsistent subsystem.
\TODO{A simple infeasible LP, with corresponding IIS as an example}
\subsection{Tests written to aid development}
Complexity of the interger programming model is large enough to not fit into
the working memory of humans. Humans can keep about 7 things in their working
memory at once~\cite{magic7}. When developing the model a lot of time was
consumed by manually altering the initial status of the model and then checking
if the feasible optimal solution to model was indeed a valid sequence of
actions. To cut down the time on manual rewriting of the initial status and
manual checking of solutions, several test scenarios were created.

Some of these test are meant to be infeasible. Others have expected outcomes,
which are checked. When an specific objective function is not mentioned, the
objective function will be left empty for that test.

The initial node statuses are fixed for every test. To easily display the
initial statuses, we use images that depict the underlying graph of the problem
and the node statuses at timestep 0. In the images, nodes are represented as
circles. They gray lines between nodes show that there is an edge between those
vertices. Inside the circles the upper text shows the node status and the lower
text shows the identifier of the node.
\subsubsection{Collision}
The purpose of this test is to make sure head on collisions are infeasible in
the model.
\testImage{collision}{Initial node statuses for collision test.}
To force a collision, we use constraints to fix the values of some decision
variables.
\begin{align}
    \go_{(0,1),\stat{r},\De,0} &= 1\\
    \go_{(1,1),\stat{r},\Dw,0} &= 1
\end{align}
The desired output is infeasibility of the model.
\subsubsection{Collision with same destination}
Next test makes sure two robots cannot move into the same node at the same
time.
\testImage{collision2}{Initial node statuses for collision test with same
destination.}
The constraints force both of the robots to start moving to node $(1,0)$.
\begin{align}
    \go_{(2,0),\stat{r},\Dw,0} &= 1\\
    \go_{(1,1),\stat{r},\Dn,0} &= 1
\end{align}
As with the last test, this collision should be infeasible.
\subsubsection{Collision with special}
Last two test made sure that robots cannot collide, but another test is needed
for robots carrying different types of cars.
\testImage{collisionspecial}{Initial node statuses for collision test with
loaded robots}
\begin{align}
    \go_{(0,1),\stat{0r},\De,0} &= 1\\
    \go_{(1,1),\stat{1r},\Dw,0} &= 1
\end{align}
As with other collision tests, the model should be infeasible.
\subsubsection{Orthogonal collision}
We also have a test for collision with orthogonal directions.
\testImage{collisionorth}{Initial node statuses for collision test with
orthogonal directions}
Here robot on $(1,0)$ is moving away from it, and robot on $(1,1)$ is trying to
move into $(1,0)$. This collision was explained in~\autoref{fig:orthcol}.
\begin{align}
    \go_{(1,0),\stat{r},\Dw,0} &= 1\\
    \go_{(1,1),\stat{r},\Dn,0} &= 1
\end{align}
Because of the collision, the model should be infeasible.
\subsubsection{Collision with itself}
This is a test to see that edge constraints have the right number of timesteps.
\testImage{collisionself}{Initial node statuses for collision test with
itself.}
\begin{align}
    \go_{(2,0),\stat{r},\Dw,0} &= 1\\
    \go_{(1,0),\stat{r},\De,2} &= 1
\end{align}
When the edges are occupied for longer than actually needed, the model will
become infeasible, because the first movement marks edge $((2,0),(1,0))$ as
occupied, and the second movement marks edge $((1,0),(2,0))$ as occupied. And
they cannot be both occupied at the same time thanks to
constraint~\eqref{eq:antiedges}.

This model should be feasible.
\subsubsection{Moving together}
With this test, we make sure that robots can move in the same direction side by
side.
\testImage{movetogether}{Initial node statuses for moving together test.}
Both robots are forced to move at the start.
\begin{align}
    \go_{(1,0),\stat{r},\Dw,0} &= 1\\
    \go_{(2,0),\stat{r},\Dw,0} &= 1
\end{align}
The model should be feasible and optimal solution is also verified by following
checks.
\begin{align}
    \nstat_{(0,0), \stat{r}, 2} &\ife 1\\
    \nstat_{(1,0), \stat{r}, 2} &\ife 1\\
    \nstat_{(2,0), \stat{e}, 2} &\ife 1
\end{align}

\subsubsection{Moving together different}
This is quite similar to last test, but now we have other than empty nodes in
the way and one of the robots is also carrying a car.
\testImage{movetogetherdiff}{Initial node statuses for moving together test
with a car on the way and the last robot carrying a car.}
\begin{align}
    \go_{(1,0),\stat{r},\Dw,0} &= 1\\
    \go_{(2,0),\stat{r},\Dw,0} &= 1\\
    \go_{(3,0),\stat{r},\Dw,0} &= 1\\
    \go_{(4,0),\stat{0r},\Dw,0} &= 1
\end{align}
The model should be feasible and optimal solution is verified by following
checks.
\begin{align}
    \nstat_{(1,0), \stat{r1}, 2} &\ife 1\\
    \nstat_{(1,0), \stat{r}, 2} &\ife 1\\
    \nstat_{(2,0), \stat{r0}, 2} &\ife 1\\
    \nstat_{(3,0), \stat{0r}, 3} &\ife 1\\
    \nstat_{(4,0), \stat{e}, 3} &\ife 1
\end{align}

\subsubsection{Moving together bad}
This test checks if node statuses are handled correctly when things move
together.
\testImage{movetogetherbad}{Initial node statuses for moving together test
with an invalid node status constraint.}
\begin{align}
    \go_{(1,0),\stat{r},\Dw,0} &= 1\\
    \go_{(2,0),\stat{r},\Dw,0} &= 1\\
    \nstat_{(1,0),\stat{r0},2} &= 1
\end{align}
The status of node $(1,0)$ after the movement, at timestep 2 should
be~$\stat{r}$. However, we give a constraint which should make the model
infeasible.
\subsubsection{Lift and move}
This test checks if the model can find a correct solution to a simple problem.
\testImage{liftandmove}{Initial node statuses for the lift and move test.}
This time instead of adding constraints to force some actions, we define the
objective function.
\begin{align}
    \min \sum_{t \in \T} -\nstat_{(0,0), \stat{r0}, t}
\end{align}
Correct solution would be for the robot to move into the middle node $(1,0)$,
lift the car from there and carry it to $(0,0)$ and finally drop it there. The
solution is checked against these conditions.
\begin{align}
    \nstat_{(0,0), \stat{e}, 2} &\ife 1\\
    \nstat_{(1,0), \stat{r0}, 2} &\ife 1\\
    \nstat_{(2,0), \stat{0}, 2} &\ife 1\\
    \nstat_{(1,0), \stat{0r}, 8} &\ife 1\\
    \nstat_{(0,0), \stat{0r}, 11} &\ife 1\\
    \nstat_{(0,0), \stat{r0}, 13} &\ife 1
\end{align}
These conditions just make sure that node statuses at various timesteps are
correct.
\subsubsection{Lift and move forced}
This test is almost the same as previous, but now the decisions are forced with
constraints.
\testImage{liftandmoveforced}{Initial node statuses for the forced lift and move test.}
\begin{align}
    \go_{(1,0),\stat{r},\Dw,0} &= 1\\
    \go_{(2,0),\stat{r},\Dw,0} &= 1\\
    \nstat_{(1,0),\stat{r0},2} &= 1
\end{align}
The objective is now to issue as many lifts at node $(0,0)$ for car of type 1
as possible.
\begin{align}
    \min \sum_{t \in \T} -\lift_{(0,0), \stat{r1}, t}
\end{align}
The solution is checked against these conditions.
\begin{align}
    \nstat_{(0,0), \stat{e}, 2} &\ife 1\\
    \nstat_{(1,0), \stat{r1}, 2} &\ife 1\\
    \nstat_{(2,0), \stat{0}, 2} &\ife 1\\
    \nstat_{(1,0), \stat{1r}, 8} &\ife 1\\
    \nstat_{(0,0), \stat{1r}, 11} &\ife 1
\end{align}
When the previous test failed, the model did something else to obtain a better
objective value. This test was added to see, if a legal sequence of decisions
was indeed feasible during the development of constraints.
\subsubsection{Persistence, no robots}
This test is to make sure that node statuses stay the same when there are no
robots.
\testImage{persistence}{Initial node statuses for the persistence test.}
We also add one odd constraint.
\begin{align}
    \nstat_{(0,0),\stat{r},20} &= 1
\end{align}
And the objective used is different to encourage occupying edges and
appearance of robots.
\begin{align}
    \min \sum_{t \in \T}\left( -4\nstat_{(0,0), \stat{r}, t}
    -4\nstat_{(1,0),\stat{r},t} -\sum_{e \in \E} \occu_{e,t} \right)
\end{align}
Of course node statuses should not change by themselves, and the model should be
infeasible.

\subsubsection{Continue together}
This tests makes sure that robots can continue moving in one direction, even
when moving together. Actually it tests both a single robot continuing and at
the same time also 2 robots continuing together.
\testImage{largetest}{Initial node statuses for the continue test.}
The objective is for robots to go to the right side.
\begin{align}
    \min \sum_{t \in \T} -\nstat_{(3,0), \stat{r}, t} -\nstat_{(3,1),\stat{r},t} -\nstat_{(2,1),\stat{r},t}
\end{align}
The model should be feasible and the optimal solution is verified by hand.

\subsection{Tuning Gurobi parameters}
